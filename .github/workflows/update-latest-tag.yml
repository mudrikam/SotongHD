name: Update 'latest' Tag

on:
  workflow_run:
    workflows: [ "Create Release ZIPs", "Build Executable Files" ]
    types: [ completed ]
  release:
    types: [ published, edited ]
  workflow_dispatch:
    inputs:
      tag:
        description: 'Optional: source tag to point `latest` to. If empty the workflow will use the release tag (for release events) or the most recent tag.'
        required: false

permissions:
  contents: write

jobs:
  update-latest:
    if: ${{ github.event_name == 'release' || github.event_name == 'workflow_dispatch' || (github.event_name == 'workflow_run' && github.event.workflow_run.head_branch == 'main' && github.event.workflow_run.conclusion == 'success') }}
    runs-on: ubuntu-latest
    steps:
      - name: Find artifacts from workflow_run
        if: ${{ github.event_name == 'workflow_run' }}
        id: find_artifact
        uses: actions/github-script@v6
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const run_id = context.payload.workflow_run && context.payload.workflow_run.id;
            if (!run_id) {
              core.setOutput('found','false');
              core.setOutput('artifacts','[]');
            } else {
              const artifacts = await github.rest.actions.listWorkflowRunArtifacts({ owner, repo, run_id });
              if (!artifacts.data.artifacts || artifacts.data.artifacts.length === 0) {
                core.setOutput('found','false');
                core.setOutput('artifacts','[]');
              } else {
                const artifactsList = artifacts.data.artifacts.map(a => ({ name: a.name, archive_download_url: a.archive_download_url }));
                core.setOutput('found','true');
                core.setOutput('artifacts', JSON.stringify(artifactsList));
              }
            }

      - name: Wait for related workflow runs to complete
        if: ${{ github.event_name == 'workflow_run' }}
        uses: actions/github-script@v6
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const headSha = context.payload.workflow_run && context.payload.workflow_run.head_sha;
            if (!headSha) {
              core.setOutput('ready','false');
              throw new Error('No head SHA found on workflow_run payload');
            }

            const required = [ 'Create Release ZIPs', 'Build Executable Files' ];
            const maxAttempts = 40;
            const delayMs = 15000;
            const sleep = (ms) => new Promise((res) => setTimeout(res, ms));

            async function checkAll() {
              const runsResp = await github.rest.actions.listWorkflowRunsForRepo({ owner, repo, per_page: 100 });
              const runs = runsResp.data.workflow_runs || [];

              const result = {};
              for (const name of required) {
                const found = runs.find(r => r.name === name && r.head_sha === headSha);
                if (!found) {
                  result[name] = { found: false };
                } else {
                  result[name] = { found: true, status: found.status, conclusion: found.conclusion };
                }
              }
              return result;
            }

            let attempts = 0;
            while (attempts < maxAttempts) {
              const res = await checkAll();
              let allSuccess = true;
              let anyFailed = false;

              for (const name of required) {
                const s = res[name];
                if (!s || !s.found) {
                  allSuccess = false;
                } else if (s.conclusion !== 'success') {
                  allSuccess = false;
                  if (s.conclusion && ['failure','cancelled','timed_out'].includes(s.conclusion)) {
                    anyFailed = true;
                  }
                }
              }

              if (allSuccess) {
                core.setOutput('ready','true');
                console.log('All required workflows completed successfully.');
                break;
              }

              if (anyFailed) {
                core.setOutput('ready','false');
                throw new Error('One of the required workflows completed with failure/cancelled. Aborting to avoid partial release.');
              }

              attempts++;
              console.log(`Attempt ${attempts}/${maxAttempts} - required workflows not yet all successful, waiting ${delayMs}ms...`);
              await sleep(delayMs);
            }

            if (attempts >= maxAttempts) {
              core.setOutput('ready','false');
              throw new Error('Timeout waiting for required workflow runs to complete successfully.');
            }

      - name: Download workflow_run artifacts
        if: ${{ github.event_name == 'workflow_run' && steps.find_artifact.outputs.found == 'true' && steps.wait_for_related_workflow_runs_to_complete.outputs.ready == 'true' }}
        run: |
          echo "Downloading artifacts..."
          echo '${{ steps.find_artifact.outputs.artifacts }}' > artifacts.json
          python3 - <<'PY'
          import json, os, subprocess
          with open('artifacts.json') as f:
              arts = json.load(f)
          token = os.environ.get('GITHUB_TOKEN')
          for a in arts:
              name = a['name']
              url = a['archive_download_url']
              filename = f"{name}.zip"
              print('Downloading', name)
              subprocess.check_call(['curl','-L','-H',f'Authorization: Bearer {token}', '-o', filename, url])
              subprocess.call(['unzip','-o', filename])
          PY

      - name: Update or create refs/tags/latest (using PAT if available)
        uses: actions/github-script@v6
        env:
          PAT_TRIGGER: ${{ secrets.PAT_TRIGGER }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const pat = process.env.PAT_TRIGGER;
            let octokit = github;
            if (pat) {
              const { Octokit } = require('@octokit/rest');
              octokit = new Octokit({ auth: pat });
              console.log('Using PAT_TRIGGER for authenticated operations (will trigger release events).');
            } else {
              console.log('PAT_TRIGGER not found; operations will use GITHUB_TOKEN (events may not trigger other workflows).');
            }

            let sourceTag = '';
            let sha = '';

            if (context.eventName === 'push') {
              sha = context.payload.after;
              console.log(`Running on push event. Using push SHA: ${sha}`);
            } else if (context.eventName === 'workflow_run') {
              sha = (context.payload && context.payload.workflow_run && context.payload.workflow_run.head_sha) ? context.payload.workflow_run.head_sha : '';

              if (!sha && context.payload && context.payload.workflow_run && context.payload.workflow_run.head_commit) {
                sha = context.payload.workflow_run.head_commit.id;
              }
              console.log(`Running on workflow_run event. Using head SHA: ${sha}`);
            } else {
              if (context.eventName === 'release') {
                sourceTag = context.payload.release.tag_name;
              } else if (context.eventName === 'workflow_dispatch') {
                sourceTag = (context.payload && context.payload.inputs && context.payload.inputs.tag) ? context.payload.inputs.tag : '';
              }

              if (!sourceTag) {
                const tags = await github.rest.repos.listTags({ owner, repo, per_page: 1 });
                if (tags.data.length === 0) throw new Error('No tags found in the repository to use as source.');
                sourceTag = tags.data[0].name;
              }

              console.log(`Using source tag: ${sourceTag}`);

              try {
                const ref = await github.rest.git.getRef({ owner, repo, ref: `tags/${sourceTag}` });
                const obj = ref.data.object;
                if (obj.type === 'tag') {
                  const tagObj = await github.rest.git.getTag({ owner, repo, tag_sha: obj.sha });
                  sha = tagObj.data.object.sha;
                } else {
                  sha = obj.sha;
                }
              } catch (err) {
                const tagsResp = await github.rest.repos.listTags({ owner, repo, per_page: 100 });
                const found = tagsResp.data.find(t => t.name === sourceTag);
                if (!found) throw new Error(`Failed to resolve tag ${sourceTag}: ${err.message}`);
                sha = found.commit.sha;
              }

              console.log(`Resolved SHA: ${sha}`);
            }

            try {
              await octokit.rest.git.updateRef({ owner, repo, ref: 'tags/latest', sha, force: true });
              console.log('Updated refs/tags/latest (via octokit)');
            } catch (err) {
              await octokit.rest.git.createRef({ owner, repo, ref: 'refs/tags/latest', sha });
              console.log('Created refs/tags/latest (via octokit)');
            }

            try {
              const latestRef = await octokit.rest.git.getRef({ owner, repo, ref: 'tags/latest' });
              const latestSha = latestRef.data.object.sha;
              console.log(`Resolved SHA: ${sha}`);
              console.log(`refs/tags/latest now points to: ${latestSha}`);
              console.log(`refs/tags/latest short: ${latestSha.substring(0,7)}`);

              try {
                let release = null;
                try {
                  release = await octokit.rest.repos.getReleaseByTag({ owner, repo, tag: 'latest' });
                  console.log(`Found existing release id=${release.data.id} for tag 'latest'`);

                  await octokit.rest.repos.updateRelease({ owner, repo, release_id: release.data.id, name: 'Download SotongHD' });
                  console.log('Ensured release name is "Download SotongHD" (via octokit)');
                } catch (getErr) {
                  const createResp = await octokit.rest.repos.createRelease({ owner, repo, tag_name: 'latest', name: 'Download SotongHD', draft: false, prerelease: false, target_commitish: sha });
                  console.log(`Created release 'Download SotongHD' for tag 'latest' id=${createResp.data.id} (via octokit)`);
                  release = { data: createResp.data };
                }

                try {
                  const fs = require('fs');
                  const files = fs.readdirSync('.');
                  const candidates = files.filter(f => /SotongHD.*\.(zip|exe|tar\.xz)$/.test(f));
                  if (candidates.length === 0) {
                    console.log('No SotongHD release artifacts found to upload.');
                  } else {
                    const release_id = release.data.id;
                    for (const f of candidates) {
                      const assets = await octokit.rest.repos.listReleaseAssets({ owner, repo, release_id });
                      const oldAsset = assets.data.find(a => a.name === f);
                      if (oldAsset) {
                        await octokit.rest.repos.deleteReleaseAsset({ owner, repo, asset_id: oldAsset.id });
                        console.log(`Deleted existing asset id=${oldAsset.id}`);
                      }

                      await octokit.rest.repos.uploadReleaseAsset({ owner, repo, release_id, name: f, data: fs.readFileSync(f) });
                      console.log(`Uploaded asset ${f} to release 'Download SotongHD' id=${release_id}`);
                    }
                  }
                } catch (err) {
                  console.log('Warning: failed to upload artifact(s) to release:', err.message);
                }

              } catch (err) {
                console.log('Warning: failed to update/create release for tag latest:', err.message);
              }

            } catch (err) {
              console.log('Warning: failed to fetch refs/tags/latest after update:', err.message);
            }
