name: Update 'latest' Tag

on:
  workflow_run:
    workflows: [ "Create Release ZIPs", "Build Executable Files" ]
    types: [ completed ]
  release:
    types: [ published, edited ]
  workflow_dispatch:
    inputs:
      tag:
        description: 'Optional: source tag to point `latest` to. If empty the workflow will use the release tag (for release events) or the most recent tag.'
        required: false

permissions:
  contents: write

jobs:
  update-latest:
    if: ${{ github.event_name == 'release' || github.event_name == 'workflow_dispatch' || (github.event_name == 'workflow_run' && github.event.workflow_run.head_branch == 'main' && github.event.workflow_run.conclusion == 'success') }}
    runs-on: ubuntu-latest
    steps:
      - name: Find artifacts from workflow_run
        if: ${{ github.event_name == 'workflow_run' }}
        id: find_artifact
        uses: actions/github-script@v6
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const run_id = context.payload.workflow_run && context.payload.workflow_run.id;
            if (!run_id) {
              core.setOutput('found','false');
              core.setOutput('artifacts','[]');
            } else {
              const artifacts = await github.rest.actions.listWorkflowRunArtifacts({ owner, repo, run_id });
              if (!artifacts.data.artifacts || artifacts.data.artifacts.length === 0) {
                core.setOutput('found','false');
                core.setOutput('artifacts','[]');
              } else {
                const list = artifacts.data.artifacts.map(a => ({ name: a.name, archive_download_url: a.archive_download_url }));
                core.setOutput('found','true');
                core.setOutput('artifacts', JSON.stringify(list));
              }
            }

      - name: Download workflow_run artifacts
        if: ${{ github.event_name == 'workflow_run' && steps.find_artifact.outputs.found == 'true' }}
        run: |
          echo "Downloading artifacts..."
          echo '${{ steps.find_artifact.outputs.artifacts }}' > artifacts.json
          python3 - <<'PY'
          import json, os, subprocess
          with open('artifacts.json') as f:
              arts = json.load(f)
          token = os.environ.get('GITHUB_TOKEN')
          for a in arts:
              name = a['name']
              url = a['archive_download_url']
              filename = f"{name}.zip"
              print('Downloading', name)
              subprocess.check_call(['curl','-L','-H',f'Authorization: Bearer {token}', '-o', filename, url])
              subprocess.call(['unzip','-o', filename])
          PY

      - name: Update or create refs/tags/latest (using PAT if available)
        uses: actions/github-script@v6
        env:
          PAT_TRIGGER: ${{ secrets.PAT_TRIGGER }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Use PAT if provided to perform release/tag operations (events created by a PAT will trigger other workflows)
            const pat = process.env.PAT_TRIGGER;
            let octokit = github;
            if (pat) {
              const { Octokit } = require('@octokit/rest');
              octokit = new Octokit({ auth: pat });
              console.log('Using PAT_TRIGGER for authenticated operations (will trigger release events).');
            } else {
              console.log('PAT_TRIGGER not found; operations will use GITHUB_TOKEN (events may not trigger other workflows).');
            }

            let sourceTag = '';
            let sha = '';

            if (context.eventName === 'push') {
              // On push to main, use the pushed commit as the source
              sha = context.payload.after;
              console.log(`Running on push event. Using push SHA: ${sha}`);
            } else if (context.eventName === 'workflow_run') {
              // On workflow_run (triggered by Create Release ZIPs), use the head SHA of the workflow run
              sha = (context.payload && context.payload.workflow_run && context.payload.workflow_run.head_sha) ? context.payload.workflow_run.head_sha : '';
              // fallback to head_commit id if available
              if (!sha && context.payload && context.payload.workflow_run && context.payload.workflow_run.head_commit) {
                sha = context.payload.workflow_run.head_commit.id;
              }
              console.log(`Running on workflow_run event. Using head SHA: ${sha}`);
            } else {
              if (context.eventName === 'release') {
                sourceTag = context.payload.release.tag_name;
              } else if (context.eventName === 'workflow_dispatch') {
                sourceTag = (context.payload && context.payload.inputs && context.payload.inputs.tag) ? context.payload.inputs.tag : '';
              }

              if (!sourceTag) {
                const tags = await github.rest.repos.listTags({ owner, repo, per_page: 1 });
                if (tags.data.length === 0) throw new Error('No tags found in the repository to use as source.');
                sourceTag = tags.data[0].name;
              }

              console.log(`Using source tag: ${sourceTag}`);

              // Resolve tag -> commit SHA
              try {
                const ref = await github.rest.git.getRef({ owner, repo, ref: `tags/${sourceTag}` });
                const obj = ref.data.object;
                if (obj.type === 'tag') {
                  // annotated tag -> resolve to commit
                  const tagObj = await github.rest.git.getTag({ owner, repo, tag_sha: obj.sha });
                  sha = tagObj.data.object.sha;
                } else {
                  // lightweight tag
                  sha = obj.sha;
                }
              } catch (err) {
                // fallback: list tags and find commit sha
                const list = await github.rest.repos.listTags({ owner, repo, per_page: 100 });
                const found = list.data.find(t => t.name === sourceTag);
                if (!found) throw new Error(`Failed to resolve tag ${sourceTag}: ${err.message}`);
                sha = found.commit.sha;
              }

              console.log(`Resolved SHA: ${sha}`);
            }

            // Update refs/tags/latest (force) or create if missing using octokit (PAT if available)
            try {
              await octokit.rest.git.updateRef({ owner, repo, ref: 'tags/latest', sha, force: true });
              console.log('Updated refs/tags/latest (via octokit)');
            } catch (err) {
              await octokit.rest.git.createRef({ owner, repo, ref: 'refs/tags/latest', sha });
              console.log('Created refs/tags/latest (via octokit)');
            }

            // Confirm the refs/tags/latest points to the expected SHA and print hash
            try {
              const latestRef = await octokit.rest.git.getRef({ owner, repo, ref: 'tags/latest' });
              const latestSha = latestRef.data.object.sha;
              console.log(`Resolved SHA: ${sha}`);
              console.log(`refs/tags/latest now points to: ${latestSha}`);
              console.log(`refs/tags/latest short: ${latestSha.substring(0,7)}`);

              // Update or create a Release for tag 'latest' and write the resolved SHA into its body (do NOT copy assets)
              try {
                let release = null;
                try {
                  release = await octokit.rest.repos.getReleaseByTag({ owner, repo, tag: 'latest' });
                  console.log(`Found existing release id=${release.data.id} for tag 'latest'`);

                  const oldBody = release.data.body || '';
                  const line = `**latest tag commit:** ${sha} (short: ${sha.substring(0,7)})`;

                  // replace existing line if any, otherwise append
                  const newBody = oldBody.replace(/\*\*latest tag commit:\*\*.*(?:\r\n|\n)?/i, `${line}\n`);
                  const finalBody = (newBody === oldBody) ? (oldBody + `\n\n${line}`) : newBody;

                  await octokit.rest.repos.updateRelease({ owner, repo, release_id: release.data.id, name: 'Download SotongHD', body: finalBody });
                  console.log('Updated release "Download SotongHD" body for tag latest (via octokit)');
                } catch (getErr) {
                  // If not found, create a release with tag 'latest' (assets should be uploaded by the build job)
                  const createResp = await octokit.rest.repos.createRelease({ owner, repo, tag_name: 'latest', name: 'Download SotongHD', body: `**latest tag commit:** ${sha} (short: ${sha.substring(0,7)})`, draft: false, prerelease: false, target_commitish: sha });
                  console.log(`Created release 'Download SotongHD' for tag 'latest' id=${createResp.data.id} (via octokit)`);
                  release = { data: createResp.data };
                }

                // Try to upload any SotongHD artifacts that were downloaded
                try {
                  const fs = require('fs');
                  const files = fs.readdirSync('.');
                  const candidates = files.filter(f => /SotongHD.*\.(zip|exe|tar\.xz)$/.test(f));
                  if (candidates.length === 0) {
                    console.log('No SotongHD release artifacts found to upload.');
                  } else {
                    const release_id = release.data.id;
                    for (const f of candidates) {
                      const assets = await octokit.rest.repos.listReleaseAssets({ owner, repo, release_id });
                      const oldAsset = assets.data.find(a => a.name === f);
                      if (oldAsset) {
                        await octokit.rest.repos.deleteReleaseAsset({ owner, repo, asset_id: oldAsset.id });
                        console.log(`Deleted existing asset id=${oldAsset.id}`);
                      }

                      await octokit.rest.repos.uploadReleaseAsset({ owner, repo, release_id, name: f, data: fs.readFileSync(f) });
                      console.log(`Uploaded asset ${f} to release 'Download SotongHD' id=${release_id}`);
                    }
                  }
                } catch (err) {
                  console.log('Warning: failed to upload artifact(s) to release:', err.message);
                }

              } catch (err) {
                console.log('Warning: failed to update/create release for tag latest:', err.message);
              }

            } catch (err) {
              console.log('Warning: failed to fetch refs/tags/latest after update:', err.message);
            }
