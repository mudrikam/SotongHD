name: Update 'latest' Tag

on:
  workflow_run:
    workflows: [ "Create Release ZIPs" ]
    types: [ completed ]
  release:
    types: [ published, edited ]
  workflow_dispatch:
    inputs:
      tag:
        description: 'Optional: source tag to point `latest` to. If empty the workflow will use the release tag (for release events) or the most recent tag.'
        required: false

permissions:
  contents: write

jobs:
  update-latest:
    if: ${{ github.event_name == 'release' || github.event_name == 'workflow_dispatch' || (github.event_name == 'workflow_run' && github.event.workflow_run.head_branch == 'main' && github.event.workflow_run.conclusion == 'success') }}
    runs-on: ubuntu-latest
    steps:
      - name: Find artifact from workflow_run
        if: ${{ github.event_name == 'workflow_run' }}
        id: find_artifact
        uses: actions/github-script@v6
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const run_id = context.payload.workflow_run && context.payload.workflow_run.id;
            if (!run_id) {
              core.setOutput('found','false');
            } else {
              const artifacts = await github.rest.actions.listWorkflowRunArtifacts({ owner, repo, run_id });
              const art = artifacts.data.artifacts.find(a => a.name === 'SotongHDx86_64');
              if (!art) {
                core.setOutput('found','false');
              } else {
                core.setOutput('found','true');
                core.setOutput('archive_download_url', art.archive_download_url);
                core.setOutput('artifact_id', String(art.id));
              }
            }

      - name: Download workflow_run artifact
        if: ${{ github.event_name == 'workflow_run' && steps.find_artifact.outputs.found == 'true' }}
        run: |
          echo "Downloading artifact..."
          curl -L -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" -o artifact.zip "${{ steps.find_artifact.outputs.archive_download_url }}"
          unzip -o artifact.zip || true

      - name: Update or create refs/tags/latest (using PAT if available)
        uses: actions/github-script@v6
        env:
          PAT_TRIGGER: ${{ secrets.PAT_TRIGGER }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Use PAT if provided to perform release/tag operations (events created by a PAT will trigger other workflows)
            const pat = process.env.PAT_TRIGGER;
            let octokit = github;
            if (pat) {
              const { Octokit } = require('@octokit/rest');
              octokit = new Octokit({ auth: pat });
              console.log('Using PAT_TRIGGER for authenticated operations (will trigger release events).');
            } else {
              console.log('PAT_TRIGGER not found; operations will use GITHUB_TOKEN (events may not trigger other workflows).');
            }

            let sourceTag = '';
            let sha = '';

            if (context.eventName === 'push') {
              // On push to main, use the pushed commit as the source
              sha = context.payload.after;
              console.log(`Running on push event. Using push SHA: ${sha}`);
            } else if (context.eventName === 'workflow_run') {
              // On workflow_run (triggered by Create Release ZIPs), use the head SHA of the workflow run
              sha = (context.payload && context.payload.workflow_run && context.payload.workflow_run.head_sha) ? context.payload.workflow_run.head_sha : '';
              // fallback to head_commit id if available
              if (!sha && context.payload && context.payload.workflow_run && context.payload.workflow_run.head_commit) {
                sha = context.payload.workflow_run.head_commit.id;
              }
              console.log(`Running on workflow_run event. Using head SHA: ${sha}`);
            } else {
              if (context.eventName === 'release') {
                sourceTag = context.payload.release.tag_name;
              } else if (context.eventName === 'workflow_dispatch') {
                sourceTag = (context.payload && context.payload.inputs && context.payload.inputs.tag) ? context.payload.inputs.tag : '';
              }

              if (!sourceTag) {
                const tags = await github.rest.repos.listTags({ owner, repo, per_page: 1 });
                if (tags.data.length === 0) throw new Error('No tags found in the repository to use as source.');
                sourceTag = tags.data[0].name;
              }

              console.log(`Using source tag: ${sourceTag}`);

              // Resolve tag -> commit SHA
              try {
                const ref = await github.rest.git.getRef({ owner, repo, ref: `tags/${sourceTag}` });
                const obj = ref.data.object;
                if (obj.type === 'tag') {
                  // annotated tag -> resolve to commit
                  const tagObj = await github.rest.git.getTag({ owner, repo, tag_sha: obj.sha });
                  sha = tagObj.data.object.sha;
                } else {
                  // lightweight tag
                  sha = obj.sha;
                }
              } catch (err) {
                // fallback: list tags and find commit sha
                const list = await github.rest.repos.listTags({ owner, repo, per_page: 100 });
                const found = list.data.find(t => t.name === sourceTag);
                if (!found) throw new Error(`Failed to resolve tag ${sourceTag}: ${err.message}`);
                sha = found.commit.sha;
              }

              console.log(`Resolved SHA: ${sha}`);
            }

            // Update refs/tags/latest (force) or create if missing using octokit (PAT if available)
            try {
              await octokit.rest.git.updateRef({ owner, repo, ref: 'tags/latest', sha, force: true });
              console.log('Updated refs/tags/latest (via octokit)');
            } catch (err) {
              await octokit.rest.git.createRef({ owner, repo, ref: 'refs/tags/latest', sha });
              console.log('Created refs/tags/latest (via octokit)');
            }

            // Confirm the refs/tags/latest points to the expected SHA and print hash
            try {
              const latestRef = await octokit.rest.git.getRef({ owner, repo, ref: 'tags/latest' });
              const latestSha = latestRef.data.object.sha;
              console.log(`Resolved SHA: ${sha}`);
              console.log(`refs/tags/latest now points to: ${latestSha}`);
              console.log(`refs/tags/latest short: ${latestSha.substring(0,7)}`);

              // Update or create a Release for tag 'latest' and write the resolved SHA into its body (do NOT copy assets)
              try {
                let release = null;
                try {
                  release = await octokit.rest.repos.getReleaseByTag({ owner, repo, tag: 'latest' });
                  console.log(`Found existing release id=${release.data.id} for tag 'latest'`);

                  const oldBody = release.data.body || '';
                  const line = `**latest tag commit:** ${sha} (short: ${sha.substring(0,7)})`;

                  // replace existing line if any, otherwise append
                  const newBody = oldBody.replace(/\*\*latest tag commit:\*\*.*(?:\r\n|\n)?/i, `${line}\n`);
                  const finalBody = (newBody === oldBody) ? (oldBody + `\n\n${line}`) : newBody;

                  await octokit.rest.repos.updateRelease({ owner, repo, release_id: release.data.id, body: finalBody });
                  console.log('Updated release body for tag latest (via octokit)');
                } catch (getErr) {
                  // If not found, create a release with tag 'latest' (assets should be uploaded by the build job)
                  const createResp = await octokit.rest.repos.createRelease({ owner, repo, tag_name: 'latest', name: 'latest', body: `**latest tag commit:** ${sha} (short: ${sha.substring(0,7)})`, draft: false, prerelease: false, target_commitish: sha });
                  console.log(`Created release for tag 'latest' id=${createResp.data.id} (via octokit)`);
                  release = { data: createResp.data };
                }

                // Try to upload SotongHDx86_64.zip if present
                try {
                  const fs = require('fs');
                  const path = './SotongHDx86_64.zip';
                  if (fs.existsSync(path)) {
                    const release_id = release.data.id;

                    // delete existing asset with same name if present
                    const assets = await octokit.rest.repos.listReleaseAssets({ owner, repo, release_id });
                    const oldAsset = assets.data.find(a => a.name === 'SotongHDx86_64.zip');
                    if (oldAsset) {
                      await octokit.rest.repos.deleteReleaseAsset({ owner, repo, asset_id: oldAsset.id });
                      console.log(`Deleted existing asset id=${oldAsset.id}`);
                    }

                    const uploadResp = await octokit.rest.repos.uploadReleaseAsset({
                      owner,
                      repo,
                      release_id,
                      name: 'SotongHDx86_64.zip',
                      data: fs.readFileSync(path)
                    });
                    console.log(`Uploaded asset SotongHDx86_64.zip to release latest id=${release_id}`);
                  } else {
                    console.log('No SotongHDx86_64.zip file present to upload.');
                  }
                } catch (err) {
                  console.log('Warning: failed to upload asset to release latest:', err.message);
                }

              } catch (err) {
                console.log('Warning: failed to update/create release for tag latest:', err.message);
              }

            } catch (err) {
              console.log('Warning: failed to fetch refs/tags/latest after update:', err.message);
            }
